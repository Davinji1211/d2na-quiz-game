<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D²NA 任務：GPT 城全面停電！</title>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-M18NNQ8YDF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-M18NNQ8YDF');
    </script>
    <!-- End Google tag (gtag.js) -->

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        body{background-color:#1a1a2e;color:#fff;font-family:'Press Start 2P',cursive;display:flex;justify-content:center;align-items:center;min-height:100vh;margin:0;font-size:14px;line-height:1.8}
        .game-container{width:100%;max-width:800px;border:4px solid #f92a82;background-color:#0d0d1a;box-shadow:0 0 20px #f92a82,0 0 30px #f92a82 inset;padding:20px;position:relative;overflow:hidden}
        .screen{display:flex;flex-direction:column;align-items:center;text-align:center}
        .hidden{display:none!important}
        .screen-image{width:100%;max-height:350px;object-fit: contain;border:3px solid #00e5ff;margin-bottom:20px;image-rendering:pixelated;background-color: #000;}
        .text-box{background:rgba(0,0,0,.6);border:2px solid #a100ff;padding:15px;width:calc(100% - 34px)}
        h1{color:#f9e200;text-shadow:2px 2px #f92a82;font-size:24px;margin-bottom:15px}
        h2{color:#00e5ff;font-size:18px;margin:10px 0}
        p{margin:10px 0}
        .action-button,.option-button{font-family:'Press Start 2P',cursive;background-color:#f9e200;color:#1a1a2e;border:2px solid #fff;padding:15px 25px;font-size:16px;cursor:pointer;text-shadow:none;margin-top:20px;transition:all .2s ease}
        .action-button:hover,.option-button:hover{background-color:#f92a82;color:#fff;box-shadow:0 0 15px #f92a82}
        .chip-text{color:#39ff14}
        .player-guide{border-top:2px dashed #00e5ff;border-bottom:2px dashed #00e5ff;padding:10px 0;margin-top:20px;font-size:12px}
        .game-header{width:100%;margin-bottom:15px;display:flex;justify-content:space-between;align-items:center}
        #progress-bar-container{width:70%;height:20px;border:2px solid #fff;background-color:#333}
        #progress-bar{width:0;height:100%;background:linear-gradient(90deg,#f92a82,#f9e200);transition:width .5s ease}
        #chips-collected-display{display:flex;gap:8px}
        .chip-icon{width: 32px;height: 32px;filter:grayscale(100%) opacity(.5);}
        .chip-icon.unlocked{filter:none}
        #options-container{display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-top:20px}
        .option-button{width:100%;padding:12px;font-size:12px;margin-top:0;text-align:left}
        .option-button.correct{background-color:#39ff14;box-shadow:0 0 15px #39ff14}
        .option-button.wrong{background-color:#ff3c3c;box-shadow:0 0 15px #ff3c3c}
        .feedback-box{cursor:pointer}
        #feedback-title{font-size:28px;margin-bottom:15px}
        .click-to-continue{color:#f9e200;margin-top:20px;animation:blink 1.5s linear infinite}
        @keyframes blink{50%{opacity:0}}
        .transition-box{border-color:#39ff14;box-shadow:0 0 20px #39ff14}
        .chip-reward{margin:20px 0}
        .chip-reward img{width: 120px;height: 120px;}
        .chip-reward p{color:#f9e200;font-size:16px}
        #end-score{color:#f9e200;font-size:22px}
        .summary{text-align:left;background:rgba(0,0,0,.7);padding:15px;margin-top:20px;border-left:3px solid #00e5ff;font-size:12px}
        .summary h3{color:#f9e200;font-size:14px}
        .reward-link{margin-top:20px}
        #end-link{display:inline-block;background-color:#39ff14}
        #end-link:hover{background-color:#f9e200}
        #admin-stats{position:absolute;bottom:5px;right:5px;font-size:10px;background:#000;padding:5px;border:1px solid #fff;opacity:.7;z-index:100}
    </style>
</head>
<body>
    <div class="game-container">

        <!-- HTML結構 -->
        <div id="start-screen" class="screen"><img src="images/gptcity_crisis.png" alt="GPT City Blackout" class="screen-image"><div class="text-box"><h1>D²NA 任務：GPT 城全面停電！</h1><p>⚡⚠️　警報！警報！　⚡⚠️<br>駭客在 GPT 城核心「D²NA 反應爐」植入病毒，城市霓虹瞬間熄滅，所有系統瀕臨崩潰！<br>唯有集齊四枚 D²NA 晶片，才能重啟反應爐、點亮整座城市——<br><span class="chip-text">• D-chip　　⇢ 指令輸入精度</span><br><span class="chip-text">• ²-chip　　⇢ 雙倍生成敏捷</span><br><span class="chip-text">• N-chip　　⇢ 神經網路算力</span><br><span class="chip-text">• A-chip　　⇢ 安全監控防護</span><br><br>你是最後的像素維修員 <b>TAKEDA Kid</b>，<br>立即啟程：闖入五大區域，奪回晶片，護送至終端 <b>「GPT Nexus」</b>！<br></p><div class="player-guide"><p>✦ 共 10 題挑戰，答對題目以獲取反應爐能量</p><p>✦ 點擊選項作答；每題解說後點擊畫面續行</p><p>✦ 你的目標是集滿四晶片，超頻重啟反應爐！</p></div><button id="start-button" class="action-button">▶︎　出發！啟動維修任務</button></div></div>
        <div id="transition-screen" class="screen hidden"><div class="text-box transition-box"><div id="chip-unlocked" class="chip-reward"></div><h2 id="transition-title"></h2><p id="transition-text"></p><button id="continue-button" class="action-button">繼續前進</button></div></div>
        <div id="game-screen" class="screen hidden"><div class="game-header"><div id="progress-bar-container"><div id="progress-bar"></div></div><div id="chips-collected-display"></div></div><img id="question-image" src="" alt="Question Scene" class="screen-image"><div class="text-box"><h2 id="question-text"></h2><div id="options-container"></div></div></div>
        <div id="feedback-screen" class="screen hidden" onclick="nextStep()"><img id="feedback-image" src="" alt="Answer Scene" class="screen-image"><div class="text-box feedback-box"><h2 id="feedback-title"></h2><p id="feedback-explanation"></p><p class="click-to-continue">-- 點擊畫面進入下一題 --</p></div></div>
        <div id="end-screen" class="screen hidden"><img id="end-image" src="" alt="Final Result" class="screen-image"><div class="text-box"><h1 id="end-title"></h1><h2 id="end-score"></h2><p id="end-encouragement"></p><div class="summary"><h3>本次任務摘要：</h3><p id="end-summary-text"></p><h3>維修建議：</h3><p id="end-recommendation"></p></div><div class="reward-link"><p>領取你的 Bloom Learning Hour 獎勵！</p><a id="end-link" href="" target="_blank" class="action-button">點此領取</a></div><button id="restart-button" class="action-button">▶︎　再次挑戰</button></div></div>
        <div id="admin-stats" class="hidden"><p>不重複玩家數: <span id="unique-players"></span></p><p>總遊玩次數: <span id="total-plays"></span></p></div>
    </div>

    <!-- ▼▼▼ 新增的音樂播放器 ▼▼▼ -->
    <audio id="background-music" src="audio/bgm.mp3" loop></audio>
    <!-- ▲▲▲ 新增的音樂播放器 ▲▲▲ -->

    <script>
        // DOM 元素獲取
        const screens = { start: document.getElementById('start-screen'), transition: document.getElementById('transition-screen'), game: document.getElementById('game-screen'), feedback: document.getElementById('feedback-screen'), end: document.getElementById('end-screen'), };
        const buttons = { start: document.getElementById('start-button'), continue: document.getElementById('continue-button'), restart: document.getElementById('restart-button'), };
        const elements = { transitionTitle: document.getElementById('transition-title'), transitionText: document.getElementById('transition-text'), chipUnlocked: document.getElementById('chip-unlocked'), progressBar: document.getElementById('progress-bar'), chipsDisplay: document.getElementById('chips-collected-display'), questionImage: document.getElementById('question-image'), questionText: document.getElementById('question-text'), optionsContainer: document.getElementById('options-container'), feedbackImage: document.getElementById('feedback-image'), feedbackTitle: document.getElementById('feedback-title'), feedbackExplanation: document.getElementById('feedback-explanation'), endImage: document.getElementById('end-image'), endTitle: document.getElementById('end-title'), endScore: document.getElementById('end-score'), endEncouragement: document.getElementById('end-encouragement'), endSummary: document.getElementById('end-summary-text'), endRecommendation: document.getElementById('end-recommendation'), endLink: document.getElementById('end-link'), adminStats: document.getElementById('admin-stats'), uniquePlayers: document.getElementById('unique-players'), totalPlays: document.getElementById('total-plays'), };

        // 題庫
        const allQuestions = [
            { id: 1, tag: 'PRM', question: "為啥有時候 AI 回的答案，跟我們心裡想的差很大？", options: ["AI 還不夠聰明啦", "AI 的插頭沒插好？", "我們給 AI 的「指令」太模糊，害它會錯意", "AI 隨機亂回"], answer: 2, explanation: "當我們向 AI 系統提出問題時，AI 並不是「讀心術」機器，它的回答完全仰賴你給的文字提示（Prompt）。如果這段文字含糊、不完整或沒有明確方向，AI 就只能根據最接近它所訓練到的語料與模式來「猜」你想要什麼，因此常常出現答案跟心中預期相差甚遠的情況。<br>請參考以下觀念：<br>* 明確性 (Clarity)：指令要具體，避免籠統用語<br>* 上下文 (Context)：提供必要背景與範例<br>* 格式規範 (Formatting)：指定回答形式（條列、摘要、長文等）<br>* 迭代優化 (Iteration)：根據 AI 回答，不斷調整與補充提示<br>* 示例引導 (Examples)：提示可幫助 AI 學習你要的寫作風格或內容架構<br>透過精心設計的 Prompt，才能讓 AI 更精準地對齊你的預期，減少「跑偏」的機率。" },
            { id: 2, tag: 'PRM', question: "跟 AI／聊天機器人對話時，我們丟給它用來驅動回應的那段文字的專有名詞是什麼？", options: ["對話框", "Prompt", "訊息", "指令"], answer: 1, explanation: "在與 AI 或聊天機器人互動時，「Prompt」不僅僅是一段文字，而是一種與模型溝通的協議：它決定了模型要扮演的角色、回答的深度與格式，以及可用的上下文範圍。透過 Prompt，你可以預先設定整體對話框架與風格，例如「你現在是專業的財務顧問」；並輸入你真正的問題或需求──比如「請用繁體中文列出五點財務規劃建議」。就像給廚師的不只是「做菜」的概念，而是一份詳盡的食譜：材料分量、烹調方式、擺盤風格都需要寫清楚，AI 才能根據這份「食譜」做出符合你預期的「料理」。" },
            { id: 3, tag: 'PRM', question: "想像你叫一個「小幫手」去買飲料，只說「幫我買飲料」，他可能帶回？", options: ["無糖純喫茶綠茶（小罐）", "可樂、手搖、咖啡通通買", "他自己最愛的飲料", "他猜你最愛的飲料"], answer: 1, explanation: "當你只對「小幫手」說「幫我買飲料」時，並未限制品牌、口味、數量或價位，小幫手為了「滿足需求」，往往會一次買齊各種常見選項：可樂、手搖飲、咖啡……這正反映出給 AI 模型太過籠統的指令時，它也會根據訓練中最常見或最安全的「預設行為」來回應，結果往往超出你的實際預期。" },
            { id: 4, tag: 'PRM', question: "想像你叫一個「小幫手」去買飲料，若想精準買到「小罐無糖純喫茶綠茶」，你應該說？", options: ["幫我買飲料", "幫我買無糖飲料", "幫我買無糖純喫茶", "幫我買小罐無糖純喫茶綠茶"], answer: 3, explanation: "要讓小幫手精準買到「小罐無糖純喫茶綠茶」，必須在指令中一次性列出所有條件──尺寸（小罐）、甜度（無糖）、品牌（純喫茶）、茶種（綠茶）。這類似於向 AI 提示時的 Prompt 精細化、設定約束條件，並透過請AI驗證（先列需求清單，再確認執行）來消除歧義，確保回應與預期一致。" },
            { id: 5, tag: 'LLM', question: "大型語言模型（LLM）是什麼樣的 AI？", options: ["只會算數學的 AI", "能理解並生成人類語言的進階 AI", "專門控制機器人的 AI", "只能翻譯語言的 AI"], answer: 1, explanation: "大型語言模型（LLM）就像一位超級博學的圖書館員：它先在海量文字裡「閱讀」學習語言規則（預訓練），再針對特定任務加強訓練（微調），所以能「讀得懂」你的問題，也能「寫得出」合乎邏輯的答案。打個比方：<br>* 理解文字：就像你跟圖書館員說「我想看關於健康飲食的書」，它會從書櫃裡快速找出相關書籍；LLM 也是根據輸入，抓重點回答問題。<br>* 生成文字：就像你請圖書館員幫你寫一份健康食譜摘要，它會把食材、步驟整理好；LLM 也能幫你寫文章、摘要或程式碼。<br>不過，它也有小缺點：<br>1. 有時會「胡扯」（hallucination），像把不存在的書名說給你聽；<br>2. 一次能處理的內容有限（context window），就像一次只能提三本書做摘要，提太多它就有點亂；<br>3. 帶著偏見，因為它學的資料裡也可能有偏見。<br>總之，LLM 就是一個懂得「聽問題」並「用文字回應」的進階 AI 助手，但要掌握它的優點和限制，才能真正派上用場。" },
            { id: 6, tag: 'LLM', question: "LLM 主要能做下列哪一件事？", options: ["自動撰寫文章、報告與 Email", "監控人體生命徵象並即時醫療處置", "直接操控自駕車在路上行駛", "保證股票投資獲利並給出買賣點"], answer: 0, explanation: "LLM 就像文字超人，最擅長用語言幫你「動手寫」：文章、報告、Email 都難不倒它。打個比方，如果你要快速寄出一封專業的面試通知，它能瞬間幫你草擬好；但它不會去量你的心跳、也不會自己開車上路、更不會保證你股票賺錢──那些都需要硬體感測、控制系統或專業投資模型，超出 LLM 的文字專長範圍。" },
            { id: 7, tag: 'HAL', question: "什麼是 AI 的「幻覺」（AI Hallucination）？", options: ["AI 畫圖時出 Bug", "AI 產生看似真實、其實錯或亂編的資訊", "AI 回答時卡住", "AI 在作夢"], answer: 1, explanation: "AI 的「幻覺」就像你問朋友「這家店賣什麼好吃？」他不知道就亂編了一道招牌菜，卻講得很有信心。AI 也是遇到不清楚的問題時，憑機率把詞語拼湊起來，看似合理卻根本不真實。<br>舉例：問它某位名人的生日，它可能給你捏造的日期。<br>為了減少幻覺，可以：<br>1. 資料檢索（RAG）：先從可靠來源抓取事實，再讓 AI 根據事實回答。<br>2. 思考鏈提示：請 AI 先列出推理步驟，再給結論，方便你檢查每一步。<br>3. 多次比對：多次生成答案，取最常出現的版本，提高正確率。" },
            { id: 8, tag: 'HAL', question: "AI 為什麼會產生「幻覺」？", options: ["AI 想開玩笑", "訓練資料不完整或有偏差，加上 AI 用機率在猜答案", "AI 對人類不爽", "AI 記憶體不夠"], answer: 1, explanation: "AI 為什麼會產生「幻覺」？就像你問朋友一些他沒聽過的冷門話題，朋友可能憑印象亂回答一通。AI 也是，如果它讀過的資料有缺漏或帶偏見，再加上用機率「猜」下個字，就容易拼出錯誤或捏造的內容。比如你問它最新一場運動比賽的比分，因為沒學到最新資料，它可能隨便湊個數字。再者，AI 無法即時查證，也有上下文解析範圍限制，都會讓幻覺更常發生。要減少這種情況，可以先從可靠來源抓取事實，再請 AI 根據這些事實回答；或者讓它分步驟列推理過程，方便你檢查每一步。" },
            { id: 9, tag: 'HAL', question: "AI 給了看似合理的醫療建議，我們該怎辦？", options: ["馬上照做", "先自己 Google", "諮詢醫生或專業人士並驗證", "相信 AI 比醫生專業"], answer: 2, explanation: "AI 在醫療建議上就像路上熱心路人：聽起來很有道理，卻不一定專業。舉例，看到街頭有人說「這藥吃了保證好」，你不會直接就去買對吧？面對 AI 提供的醫療資訊，我們也要這樣做：<br>1. 求證專業：先把 AI 的建議拿給真正的醫生或藥師看，確認安全性。<br>2. 多方查證：上網找可靠醫學網站或學術期刊，比對建議是否有臨床證據。<br>3. 綜合判斷：把 AI、專業意見和自身狀況一起考量，再做最合適的決定。<br>這樣才能避免憑 AI 回答就冒險嘗試錯誤療法，確保健康有保障。" },
            { id: 10, tag: 'PRM', question: "把跟 AI 溝通分 3 個層級，哪種「效率最低」、最容易踩雷？", options: ["日常對話式", "重點條列式", "完整說明文件式", "以上皆非"], answer: 0, explanation: "跟 AI 溝通就像跟朋友或同事溝通，可以分三種層級：<br>1. 日常對話式：隨口一丟「幫我做個簡報」，就像跟朋友聊天，回應常常跑偏，效率最低，最容易踩雷。<br>2. 重點條列式：像寫購物清單──「主題：市場分析；深度：500 字；格式：條列式」。AI 一眼就能抓重點，執行又快又準。<br>3. 完整說明文件式：像寫企劃書，附流程圖、範例、詳細規格。<br>想讓 AI 有更高命中率，別再用「隨口聊天」方式；至少用「重點條列式」的結構化指令，滿意度就會大幅提升。" },
            { id: 11, tag: 'RES', question: "訓練 LLM 是否超耗運算資源與電力？", options: ["是，功能強大但超級吃資源", "否，很節能", "只需要手機等小型裝置就搞定", "完全不用電，靠空氣發電"], answer: 0, explanation: "訓練 LLM 就像開一整座工廠做麵包：不是一台小烤箱，而是數千台高功率烤箱（GPU）24 小時同時運轉，電費就像好幾百棟大樓同時開燈空調，再加上冷卻系統和大量儲存硬碟，整個過程資源與電力消耗都超級驚人。雖然平常用 AI 不用每次都重訓，但一開始從零訓練新模型，成本真的非常高。" },
            { id: 12, tag: 'LLM', question: "若訓練資料本身有偏見，AI 生成內容會跟著偏嗎？", options: ["不會，AI 很中立", "會，AI 只能反映它學到的東西", "只有部分會偏，問題不大", "重新訓練一次就能完全去偏見"], answer: 1, explanation: "AI 偏見就像小孩從大人那邊聽到刻板印象：「女生不會下棋」或「某族群都很懶」，他就會不自覺重複。AI 也是「吃什麼學什麼」：訓練資料裡有偏見，它就會把這些偏見當常識搬出來，還可能放大。<br>舉例：如果訓練中大多數醫生都是男性，AI 生成醫生案例時也容易預設「醫生＝男性」，對女性醫生不公平。<br>要改善，就得：<br>1. 多元資料：補足不同族群、性別、文化的內容。<br>2. 偏見檢測：用工具或人工審查 AI 回答，再做微調（fine-tune）。<br>3. 後處理過濾：對可疑回應加上審核機制，避免偏見外流。" },
            { id: 13, tag: 'PRM', question: "請 AI 寫嚴肅的商業報告，若只用「閒聊口氣」下指令，結果最可能？", options: ["拿到完美報告", "內容跑偏，要大改", "AI 直接拒絕", "AI 會一直追問細節"], answer: 1, explanation: "就像主管跟你說「幫我寫份報告」，卻只是用閒聊口氣丟出指示：你很可能寫出一篇隨興的心得分享，重點不夠、格式亂掉，最後得大幅重改。AI 也一樣：複雜的商業報告若只用「隨便講講」的語氣，下出來的內容往往跑偏、缺少深度和專業架構，需要花更多時間修正。要一次到位，最少要用「重點條列式」結構化提示──主題、目的、章節大綱、數據來源、格式要求都要講清楚，AI 才能產出符合期待的報告。" },
            { id: 14, tag: 'LLM', question: "AI 能判斷文字情緒是正面、負面還中性嗎？", options: ["不能，AI 不懂情感", "可以，這叫「情緒分析」，連酸言酸語都能抓", "只能分正面或負面，偵測不到諷刺", "要人工先標註情緒 AI 才看得懂"], answer: 1, explanation: "AI 的情緒分析就像你看朋友的 LINE 訊息：<br>* 當他說「太棒了，又下雨了」，AI 能抓出語氣裡的「諷刺」，判斷是負面或中性，而不只是正面。<br>* 如果你寫「我超愛加班」，它能分辨你是真心還是在挖苦。<br>原理很簡單：AI 先學成千上萬條有標註情緒的句子，然後把「字詞組合＋上下文」對照這些例子，最後判斷正面、負面或中性。<br>為什麼能做到？<br>1. 自注意力機制：同時評估句中所有詞語間的關聯，抓出語調細節。<br>2. 多層次訓練：不只學「好壞詞彙」，還學「句子整體氛圍」。<br>3. 諷刺偵測：透過上下文差異，辨識出表面與真實情緒的不一致。" },
            { id: 15, tag: 'PRM', question: "任務超複雜、牽涉多角色時，指令該怎麼下？", options: ["簡短就好，讓 AI 自由發揮", "把角色跟步驟寫到清楚到不行", "只講最終目標", "不用交代，AI 自己會想辦法"], answer: 1, explanation: "就像你要辦一場大型聚餐，有人負責買菜、有人負責料理、有人負責佈置場地，你都要在群組裡把「角色＋任務＋時程」寫清楚，才不會大家一頭熱又互相卡位。對 AI 也是一樣：當任務超複雜、牽涉編輯、設計、校對等多個角色時，最有效率的做法就是把每個角色要做的事、順序步驟、時間節點都寫到「清楚到不行」，讓 AI 按部就班，而不是隨便丟一句「幫我搞定專案」。<br>這樣一來，AI 不但能精準分工，還能依照流程一步步產出，省掉無限迭代和溝通成本。" },
            { id: 16, tag: 'HAL', question: "AI 生成的學術、技術或法律內容，能直接拿來用嗎？", options: ["可以，AI 一定對", "不行，AI 可能亂掰，需要人工驗證", "要看題材，有時可直接用", "只要是技術文件就百分百正確"], answer: 1, explanation: "AI 生成的學術、技術或法律內容，就像朋友去網路上複製的一段合約範本或研究摘要，乍看完整專業，但細節常有錯誤、引用不全或法規已更新。舉例：如果你直接用 AI 幫你寫的契約條款簽字，事後發現漏掉重要保密條款或賠償責任，就有可能得付出高額代價。最保險的做法是：<br>1. 找專家審核：把 AI 產出的內容交給律師、教授或資深工程師檢查。<br>2. 比對來源：確認引用的法條、技術規範、研究數據是否來自官方或權威資料。<br>這樣才能在享受 AI 速度優勢的同時，避免錯誤風險。" },
            { id: 17, tag: 'PRM', question: "問 AI 「給我一些資訊」這種模糊問題，能期待它高機率給對答案嗎？", options: ["可以，AI 會讀心", "不行，模糊問題通常得到模糊答案", "只要多問幾次就會準", "AI 會自動猜到你的需求"], answer: 1, explanation: "就像你跟店員只說「我想吃東西」，他可能端來麵包也可能蛋糕，完全看運氣。對 AI 也一樣，問「給我一些資訊」太籠統，通常只能得到隨機又模糊的回答。想高命中率，就要先講清楚：主題、範圍、格式，例如「請提供五點關於在家健身的器材推薦，並附上預算」。多問幾次不如一次就說清楚。" },
            { id: 18, tag: 'LLM', question: "LLM 可以幫忙做「內容摘要」嗎？", options: ["可以，能把長文濃縮成精華", "不行，只會生成新內容", "只能摘要短篇，長篇不行", "要付費外掛才辦得到"], answer: 0, explanation: "當你看完一本厚厚的小說，想快速跟朋友分享重點，最直接的做法就是自己拿筆劃出章節大意；LLM 就能幫你做這件事——把長文提煉成精華摘要。<br>* 日常場景：想整理今天的會議紀錄，原本要自己重複聽錄音＋打重點，用 LLM 只要丟一大段文字，它就能「一句話概括」「三點重點條列」，省下好幾倍時間。<br>* 長短不限：無論是五千字的研究報告、兩萬字的政策文件，還是無數條零散的聊天室對話，LLM 都能統整出清晰摘要。<br>* 應用廣泛：從新聞文章、論文，到 Email 收件匣裡的累積訊息，都能一鍵濃縮；你只要指定「幫我生成 100 字內摘要」或「列出 5 個重點」，AI 就能迅速回覆。<br>* 注意事項：摘要質量依賴原文結構和 Prompt 清晰度，若想更精準，可加上格式要求或示例。<br>總之，LLM 是你最有效率的「摘要小幫手」，隨手一丟，就能把長篇大論變成簡潔重點！" },
            { id: 19, tag: 'PRM', question: "為什麼說「AI 好不好用，關鍵在你怎麼跟它對話」？", options: ["AI 會看你口氣", "指令越明確、越合 AI 邏輯，就越能拿到想要的結果", "AI 只是想陪你聊天", "AI 是人類好朋友"], answer: 1, explanation: "就像你跟外送員講「買飯」，他可能帶整桌菜來；如果你說「幫我點一份牛肉飯加雙倍辣、少蔥」，就能拿到剛好想吃的那一碗。同理，AI 也只會照字面執行：<br>* 指令不清，就等於把範圍打開太大，結果容易偏離重點。<br>* 指令夠明確，比如「幫我寫 300 字內的市場分析，格式要三段：背景、現況、建議」，AI 就能精準回應。<br>重點是：你的 Prompt 就是跟 AI 對話的「說話方式」和「溝通結構」，越符合 AI 的處理邏輯，成功率就越高，才能快速拿到想要的結果。接下來我都會用這種口語化、淺顯易懂、搭配生活例子的方式回答！" },
            { id: 20, tag: 'HAL', question: "下列哪一項不是 AI 「幻覺」的真實案例？", options: ["AI 捏造不存在的學術論文", "AI 給出錯誤醫療建議", "AI 正確辨識照片裡的貓咪", "AI 把歷史事件年份人物全搞混"], answer: 2, explanation: "就像你拿手機拍貓咪給朋友看，如果他說「這是隻貓」，那只是正常辨識，不算亂想；但若他開始編故事說「這隻貓是 1850 年在倫敦科研發現的新品種」，那就是亂掰了。<br>* 捏造論文（A）：好比朋友憑空說「某某大學最新發現可以逆齡」的論文，卻根本不存在，就是幻覺。<br>* 錯誤醫療建議（B）：像路邊攤老闆隨口建議你吃未經驗證的「藥方」，可能害你更糟，也是幻覺。<br>* 歷史誤述（D）：朋友把「二次大戰」和「工業革命」搞混，時間、人物全亂套，也是幻覺。<br>只有 C「正確辨識照片裡的貓咪」是 AI 真實的影像辨識能力，屬於正常功能，不算幻覺。" }
        ];

        // 關卡設定
        const levelConfig = [ { name: "Prompt Plaza", text: "指令塔訊號塔全滅，需修好 Prompt Beacon...", questionsToDraw: 3, tagPool: ['PRM'], chip: 'D', chipName: "D-chip", chipId: "d" }, { name: "Logic Lab", text: "LLM 主機核心斷線，重插 Model Socket...", questionsToDraw: 2, tagPool: ['LLM'], chip: '²', chipName: "²-chip", chipId: "2" }, { name: "Safety Street", text: "幻覺干擾雲覆蓋街區，啟動 Hallucination Filter...", questionsToDraw: 3, tagPool: ['HAL'], chip: 'N', chipName: "N-chip", chipId: "n" }, { name: "Power Plant", text: "電容室電壓掉至 0%，更換 GPU 迴路...", questionsToDraw: 1, tagPool: ['RES'], chip: 'A', chipName: "A-chip", chipId: "a" }, { name: "GPT Nexus", text: "所有晶片已就位！進入反應爐控制室進行最終認證...", questionsToDraw: 1, tagPool: ['RANDOM'], chip: null, chipName: null, chipId: null } ];
        
        // 遊戲狀態變數
        let gameState = {};
        
        // 遊戲核心功能
        function initGameState() { gameState = { score: 0, currentLevelIndex: 0, totalQuestionsInRound: 10, questionsForThisRound: [], userAnswers: [], chips: [], }; }
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[array[i], array[j]] = [array[j], array[i]]; } return array; }
        
        function setupNewRound() {
            initGameState();
            let questionPool = [...allQuestions];
            let selectedQuestions = [];
            levelConfig.forEach(level => {
                let levelQuestions;
                if (level.tagPool[0] !== 'RANDOM') {
                    let filteredPool = questionPool.filter(q => level.tagPool.includes(q.tag));
                    shuffleArray(filteredPool);
                    levelQuestions = filteredPool.slice(0, level.questionsToDraw);
                    questionPool = questionPool.filter(q => !levelQuestions.find(lq => lq.id === q.id));
                } else {
                    shuffleArray(questionPool);
                    levelQuestions = questionPool.slice(0, level.questionsToDraw);
                }
                selectedQuestions.push(...levelQuestions);
            });
            gameState.questionsForThisRound = selectedQuestions;
            updateAdminStats();
        }

        function showScreen(screenId) { Object.values(screens).forEach(screen => screen.classList.add('hidden')); screens[screenId].classList.remove('hidden'); }
        
        // ▼▼▼ 已修改的 startGame 函數 ▼▼▼
        function startGame() {
            // 嘗試播放背景音樂
            const bgm = document.getElementById('background-music');
            if (bgm.paused) { // 避免重複點擊時重新播放
                bgm.volume = 0.3; // 設定一個較舒適的背景音量(0.0 到 1.0)
                bgm.play().catch(error => {
                    console.log("音樂自動播放失敗，可能需要使用者在頁面上進行更多互動。", error);
                });
            }
            
            trackUniquePlayer();
            displayQuestion();
        }
        // ▲▲▲ 已修改的 startGame 函數 ▲▲▲
        
        function showTransition() {
            const level = levelConfig[gameState.currentLevelIndex];
            const prevLevel = gameState.currentLevelIndex > 0 ? levelConfig[gameState.currentLevelIndex - 1] : null;
            elements.chipUnlocked.innerHTML = '';
            if (prevLevel && prevLevel.chip) {
                elements.chipUnlocked.innerHTML = `<p>成功獲得 <span class="chip-text">${prevLevel.chipName}</span>!</p><img src="images/chip_${prevLevel.chipId}.png" alt="${prevLevel.chipName}">`;
            }
            elements.transitionTitle.textContent = `--- 前往 ${level.name} ---`;
            elements.transitionText.textContent = level.text;
            showScreen('transition');
        }

        function proceedToQuestions() { displayQuestion(); }
        
        function displayQuestion() {
            updateGameHeader();
            const totalAnswered = gameState.userAnswers.length;
            if (totalAnswered >= gameState.totalQuestionsInRound) { endGame(); return; }
            const question = gameState.questionsForThisRound[totalAnswered];
            elements.questionImage.src = `images/q${question.id}.png`;
            elements.questionText.textContent = `Q${totalAnswered + 1}: ${question.question}`;
            elements.optionsContainer.innerHTML = '';
            question.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'option-button';
                button.textContent = String.fromCharCode(65 + index) + '. ' + option;
                button.onclick = () => handleAnswer(index);
                elements.optionsContainer.appendChild(button);
            });
            showScreen('game');
        }

        function handleAnswer(selectedIndex) {
            const optionButtons = elements.optionsContainer.querySelectorAll('.option-button');
            optionButtons.forEach(btn => btn.disabled = true);
            const totalAnswered = gameState.userAnswers.length;
            const question = gameState.questionsForThisRound[totalAnswered];
            const isCorrect = selectedIndex === question.answer;
            if (isCorrect) { gameState.score += 10; }
            gameState.userAnswers.push({ questionId: question.id, questionText: question.question, isCorrect: isCorrect, tag: question.tag, });
            optionButtons.forEach((btn, index) => {
                if (index === question.answer) { btn.classList.add('correct');
                } else if (index === selectedIndex && !isCorrect) { btn.classList.add('wrong'); }
            });
            showFeedback(isCorrect, question);
        }
        
        function showFeedback(isCorrect, question) {
            elements.feedbackImage.src = `images/e${question.id}.png`;
            elements.feedbackTitle.textContent = isCorrect ? "答對啦！算你厲害！" : "哎呀！差一點！";
            elements.feedbackTitle.style.color = isCorrect ? '#39ff14' : '#ff3c3c';
            elements.feedbackExplanation.innerHTML = `<b>【正確答案】</b><br>${question.explanation}`;
            setTimeout(() => { showScreen('feedback'); }, 1200);
        }

        function nextStep() {
            const totalAnswered = gameState.userAnswers.length;
            if (totalAnswered >= gameState.totalQuestionsInRound) { endGame(); return; }
            let questionsInLevels = 0;
            for(let i = 0; i <= gameState.currentLevelIndex; i++) { questionsInLevels += levelConfig[i].questionsToDraw; }
            if (totalAnswered >= questionsInLevels && gameState.currentLevelIndex < levelConfig.length - 1) {
                const currentLevel = levelConfig[gameState.currentLevelIndex];
                if(currentLevel.chip) { gameState.chips.push(currentLevel.chip); }
                gameState.currentLevelIndex++;
                showTransition();
            } else {
                displayQuestion();
            }
        }

        function updateGameHeader() {
            const progress = (gameState.userAnswers.length / gameState.totalQuestionsInRound) * 100;
            elements.progressBar.style.width = `${progress}%`;
            elements.chipsDisplay.innerHTML = '';
            levelConfig.forEach(level => {
                if (level.chipId) {
                    const chipImg = document.createElement('img');
                    chipImg.src = `images/chip_${level.chipId}.png`;
                    chipImg.className = 'chip-icon';
                    if (gameState.chips.includes(level.chip)) {
                        chipImg.classList.add('unlocked');
                    }
                    elements.chipsDisplay.appendChild(chipImg);
                }
            });
        }

        function endGame() {
            trackPlayCount();
            const score = gameState.score;
            let result;
            if (score >= 100) { 
                result = { 
                    title: "D²NA 120% 超頻!!", 
                    encouragement: "完美修復！你就是 GPT 城傳奇『D²NA維修員』，全城為你閃耀！", 
                    image: "images/gptcity_core120.png", 
                    link: "https://takeda.edcast.com/insights/d-na-llm-game-min-reward-d-na-llm" 
                };
            } else if (score >= 70) { 
                result = { 
                    title: "D²NA 核心達 70%", 
                    encouragement: "「城市已重啟基本運作，僅剩部分區域無法全速運轉！再補強相關知識，GPT 城就能全功率運轉！」", 
                    image: "images/gptcity_core70.png", 
                    link: "https://takeda.edcast.com/insights/d-na-llm-game-min-reward-d-na" 
                };
            } else { 
                result = { 
                    title: "D²NA 核心僅達 30%", 
                    encouragement: "「城市雖重啟基本運作，但還需更多資料能量！回『Prompt Plaza』苦練吧！」", 
                    image: "images/gptcity_core30.png", 
                    link: "https://takeda.edcast.com/insights/d-na-llm-game-min-reward" 
                }; 
            }
            
            elements.endImage.src = result.image;
            elements.endTitle.textContent = result.title;
            elements.endScore.textContent = `最終得分：${score} / 100`;
            elements.endEncouragement.textContent = result.encouragement;
            elements.endLink.href = result.link;
            const wrongAnswers = gameState.userAnswers.filter(a => !a.isCorrect);
            if (wrongAnswers.length > 0) {
                let summaryText = "你答錯了以下題目：<br>";
                wrongAnswers.forEach(wa => { summaryText += ` - ${wa.questionText}<br>`; });
                elements.endSummary.innerHTML = summaryText;
                const wrongTags = [...new Set(wrongAnswers.map(wa => wa.tag))];
                let recommendationText = "建議你可以針對以下領域多加學習：<br>";
                const tagMap = { 'PRM': '指令技巧 (Prompt)', 'LLM': '大型語言模型 (LLM) 基礎', 'HAL': 'AI 幻覺與安全', 'RES': 'AI 資源與限制' };
                wrongTags.forEach(tag => { if (tagMap[tag]) { recommendationText += ` - ${tagMap[tag]}<br>`; } });
                elements.endRecommendation.innerHTML = recommendationText;
            } else {
                elements.endSummary.textContent = "太神啦！你竟然一題都沒錯！";
                elements.endRecommendation.textContent = "你已經是 D²NA 大師，快去拯救更多城市吧！";
            }
            showScreen('end');
        }

        // 玩家追蹤功能
        function generateUUID() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }
        function trackUniquePlayer() { let userId = localStorage.getItem('d2na_game_userId'); if (!userId) { userId = generateUUID(); localStorage.setItem('d2na_game_userId', userId); let uniqueCount = parseInt(localStorage.getItem('d2na_game_uniquePlayers') || '0'); uniqueCount++; localStorage.setItem('d2na_game_uniquePlayers', uniqueCount); } }
        
        // **整合 GA 事件的函式**
        function trackPlayCount() {
            let playCount = parseInt(localStorage.getItem('d2na_game_totalPlays') || '0');
            playCount++;
            localStorage.setItem('d2na_game_totalPlays', playCount);
            updateAdminStats();

            // 發送事件給 Google Analytics
            if (typeof gtag === 'function') {
                gtag('event', 'game_completed', {
                    'event_category': 'Game Flow',
                    'event_label': 'Player finished a round'
                });
            }
        }

        function updateAdminStats() { elements.uniquePlayers.textContent = localStorage.getItem('d2na_game_uniquePlayers') || '0'; elements.totalPlays.textContent = localStorage.getItem('d2na_game_totalPlays') || '0'; }
        
        // 事件監聽
        buttons.start.addEventListener('click', startGame);
        buttons.continue.addEventListener('click', proceedToQuestions);
        buttons.restart.addEventListener('click', () => { setupNewRound(); showScreen('start'); });
        document.addEventListener('keydown', (e) => { if (e.ctrlKey && e.altKey && e.key === 's') { elements.adminStats.classList.toggle('hidden'); } });
        
        // 遊戲初始化
        window.onload = () => {
            setupNewRound();
            showScreen('start');
        };
    </script>
</body>
</html>